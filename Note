*Thinking...*

> **Defining the Approach**
> 
> I'm currently focused on how to best translate the user's need. I'm starting by dissecting the request. My initial goal is to understand how to move a string value for `bet_type` into a `BetType` enum within C# using Dapper. The user's preferences will influence the specific method I choose to implement.
> 
> 
> **Refining the Solution**
> 
> I'm now zeroing in on the implementation. The plan is to create a Dapper `TypeHandler` with a `Parse` method that can handle various string formats from the database, specifically both snake_case and PascalCase. I'll prioritize direct enum matching, then try matching after removing underscores. Handling potential nulls is crucial.
> 
> 
> **Streamlining the Parse Method**
> 
> My current focus is on streamlining the `Parse` method's implementation. The `Enum.TryParse` method, with its case-insensitive feature, is proving to be more robust than initially anticipated. I'm leaning toward a simpler structure, minimizing the code's complexity while addressing the user's requirements for handling diverse string formats from the database. This approach should cover both formats the user specified.
> 
> 
> **Finalizing the Strategy**
> 
> I've significantly streamlined the parsing logic. The `Enum.TryParse` method, combined with case-insensitive comparisons and underscore removal, elegantly addresses both requested formats. My focus now is on incorporating the `SetValue` functionality for writing to the database, considering the existing data format in the database. I will favor snake_case.
> 
> 
> **Consolidating the Approach**
> 
> Now I'm focusing on the `SetValue` implementation within the `TypeHandler`. Given the existing mix of formats in the database, writing consistently is the next hurdle. I lean toward writing in snake_case, aligning with the observed database style, but I'll add a comment in my response suggesting the user consider a custom approach if they need a specific format during database writes.
> 
> 
> **Consolidating the Logic**
> 
> I've significantly refined the parsing strategy. A single pass using `Enum.TryParse`, after removing underscores and case-insensitive comparison, addresses both specified string formats with exceptional elegance. The plan includes the `SetValue` function. I'll utilize `ToString()` by default for `SetValue`, because of potential database format variation. I will also incorporate comments, guiding the user towards customization if specific writing formatting is necessary.
> 
> 
沒問題，這是一個非常實際的需求。資料庫裡的歷史資料格式不一致（有些是 `SNAKE_CASE`，有些是 `PascalCase`）是很常見的情況。

我們可以優化 `TypeHandler` 的邏輯：**先嘗試直接轉換，如果失敗，再嘗試移除底線後轉換**。或者更簡單一點，因為移除底線對於原本就沒有底線的字串（如 `BankerPair`）沒有影響，我們可以統一先移除底線，再進行忽略大小寫的比對。

以下是支援這兩種格式（`BANKER_PAIR` 和 `BankerPair`）的完整程式碼：

### 1. 改良版的 TypeHandler

```csharp
using Dapper;
using System;
using System.Data;
using Galaxy.SmartTable.Integration.Common.Enums; // 請替換成你實際的 namespace

public class BetTypeHandler : SqlMapper.TypeHandler<BetType>
{
    public override BetType Parse(object value)
    {
        // 1. 處理 Null 情況
        if (value == null || value is DBNull)
        {
            return BetType.Manual; // 或是你的預設值
        }

        string dbValue = value.ToString();

        // 2. 核心邏輯：統一移除底線並忽略大小寫
        // 情況 A: DB是 "BANKER_PAIR" -> 移除底線變 "BANKERPAIR" -> 忽略大小寫比對 -> 成功對應 Enum 的 BankerPair
        // 情況 B: DB是 "BankerPair"  -> 移除底線變 "BankerPair" -> 忽略大小寫比對 -> 成功對應 Enum 的 BankerPair
        // 情況 C: DB是 "TIE"         -> 移除底線變 "TIE"        -> 忽略大小寫比對 -> 成功對應 Enum 的 Tie
        
        string cleanValue = dbValue.Replace("_", "");

        if (Enum.TryParse(typeof(BetType), cleanValue, true, out var result))
        {
            return (BetType)result;
        }

        // 3. 如果真的對應不到 (例如 DB 存了 "UnknownType")，回傳預設值
        return BetType.Manual;
    }

    public override void SetValue(IDbDataParameter parameter, BetType value)
    {
        // 寫入 DB 的邏輯
        // 這裡看你的規範，通常建議統一格式寫入。
        // 如果你想存成 "BANKER_PAIR" 這種格式，你需要寫一個轉換函式。
        // 如果只是存 "BankerPair"，直接 ToString() 即可。
        
        parameter.Value = value.ToString(); 
        parameter.DbType = DbType.String;
    }
}
```

### 2. 註冊 Handler (只需執行一次)

在你的程式啟動點（例如 `Program.cs`、`Startup.cs` 或資料庫連線工廠的建構子中）：

```csharp
// 告訴 Dapper 只要看到 BetType，就用我們寫的 Handler 處理
SqlMapper.AddTypeHandler(new BetTypeHandler());
```

### 3. 為什麼這樣寫可以同時運作？

這個邏輯之所以有效，是因為 `Enum.TryParse` 的第三個參數 `ignoreCase: true` 非常強大，配合 `Replace("_", "")` 可以通吃：

| DB 值 (Input) | 處理後 (cleanValue) | Enum 名稱 (Target) | 結果 |
| :--- | :--- | :--- | :--- |
| `BANKER_PAIR` | `BANKERPAIR` | `BankerPair` | **成功** (忽略大小寫與底線) |
| `BankerPair` | `BankerPair` | `BankerPair` | **成功** (完全匹配) |
| `Small_Tiger` | `SmallTiger` | `SmallTiger` | **成功** |
| `Tie` | `Tie` | `Tie` | **成功** |

這樣你就不需要寫兩個 `if` 來判斷，邏輯最簡潔且效能最好。